<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Ocular Engine: Ocular::Core::BVHSceneTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ocular Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ocular_1_1_core_1_1_b_v_h_scene_tree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_ocular_1_1_core_1_1_b_v_h_scene_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ocular::Core::BVHSceneTree Class Reference<div class="ingroups"><a class="el" href="group___ocular.html">Ocular</a> &raquo; <a class="el" href="group___core.html">Core</a> &#124; <a class="el" href="group___ocular.html">Ocular</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_b_v_h_scene_tree_8hpp_source.html">BVHSceneTree.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ocular::Core::BVHSceneTree:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_ocular_1_1_core_1_1_b_v_h_scene_tree.png" usemap="#Ocular::Core::BVHSceneTree_map" alt=""/>
  <map id="Ocular::Core::BVHSceneTree_map" name="Ocular::Core::BVHSceneTree_map">
<area href="class_ocular_1_1_core_1_1_i_scene_tree.html" alt="Ocular::Core::ISceneTree" shape="rect" coords="0,0,179,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb8033e845c33e90c89f3c828a2ffb98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#afb8033e845c33e90c89f3c828a2ffb98">restructure</a> () override</td></tr>
<tr class="separator:afb8033e845c33e90c89f3c828a2ffb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf0400122962de731aec03071458d3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a5cf0400122962de731aec03071458d3c">destroy</a> () override</td></tr>
<tr class="separator:a5cf0400122962de731aec03071458d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0db06e34b8f4667e25296732b8f07a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#aa0db06e34b8f4667e25296732b8f07a6">addObject</a> (<a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *object) override</td></tr>
<tr class="separator:aa0db06e34b8f4667e25296732b8f07a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d2c66cef426490708adbc0aecfac24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#ae5d2c66cef426490708adbc0aecfac24">addObjects</a> (std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; const &amp;objects) override</td></tr>
<tr class="separator:ae5d2c66cef426490708adbc0aecfac24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad9359264575fe0389f48b1c7c0ef22"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#abad9359264575fe0389f48b1c7c0ef22">removeObject</a> (<a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *object) override</td></tr>
<tr class="separator:abad9359264575fe0389f48b1c7c0ef22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cfeced3c516e19fc9ab7741583b6be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#aa6cfeced3c516e19fc9ab7741583b6be">removeObjects</a> (std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; const &amp;objects) override</td></tr>
<tr class="separator:aa6cfeced3c516e19fc9ab7741583b6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c91b758e6c90df2bc050bfc69fe55e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#ab9c91b758e6c90df2bc050bfc69fe55e">getAllObjects</a> (std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const  override</td></tr>
<tr class="separator:ab9c91b758e6c90df2bc050bfc69fe55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d98bef892e8d9f92060efa908aa02b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a28d98bef892e8d9f92060efa908aa02b">getAllVisibleObjects</a> (<a class="el" href="class_ocular_1_1_math_1_1_frustum.html">Math::Frustum</a> const &amp;frustum, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const  override</td></tr>
<tr class="separator:a28d98bef892e8d9f92060efa908aa02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9afdb4c0d17443e040e332dc841cea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a7f9afdb4c0d17443e040e332dc841cea">getIntersections</a> (<a class="el" href="class_ocular_1_1_math_1_1_ray.html">Math::Ray</a> const &amp;ray, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const  override</td></tr>
<tr class="separator:a7f9afdb4c0d17443e040e332dc841cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add58dbcd6257e18f48be57796ca0b1d1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#add58dbcd6257e18f48be57796ca0b1d1">getIntersections</a> (<a class="el" href="class_ocular_1_1_math_1_1_bounds_sphere.html">Math::BoundsSphere</a> const &amp;bounds, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const  override</td></tr>
<tr class="separator:add58dbcd6257e18f48be57796ca0b1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bc8a89a227ca23393e1793cf3fe171"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#ae5bc8a89a227ca23393e1793cf3fe171">getIntersections</a> (<a class="el" href="class_ocular_1_1_math_1_1_bounds_a_a_b_b.html">Math::BoundsAABB</a> const &amp;bounds, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const  override</td></tr>
<tr class="separator:ae5bc8a89a227ca23393e1793cf3fe171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b49c3d5587aeb0cb1e6ef98f284894"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#aa2b49c3d5587aeb0cb1e6ef98f284894">getIntersections</a> (<a class="el" href="class_ocular_1_1_math_1_1_bounds_o_b_b.html">Math::BoundsOBB</a> const &amp;bounds, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const  override</td></tr>
<tr class="separator:aa2b49c3d5587aeb0cb1e6ef98f284894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbcc00d258a2448cc2851cbf0291516"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a2fbcc00d258a2448cc2851cbf0291516">setDirty</a> (<a class="el" href="class_ocular_1_1_core_1_1_u_u_i_d.html">UUID</a> const &amp;uuid) override</td></tr>
<tr class="separator:a2fbcc00d258a2448cc2851cbf0291516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65c56973c66324603e1e310d487a8bf"><td class="memItemLeft" align="right" valign="top">virtual SceneTreeType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#ac65c56973c66324603e1e310d487a8bf">getType</a> () const  override</td></tr>
<tr class="separator:ac65c56973c66324603e1e310d487a8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4e21f45bc20e23bb010051f5fb439bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a4e21f45bc20e23bb010051f5fb439bcb">rebuild</a> ()</td></tr>
<tr class="separator:a4e21f45bc20e23bb010051f5fb439bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea537636e8c42e84195c9f6bc8dfb52a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#aea537636e8c42e84195c9f6bc8dfb52a">insertNewObjects</a> ()</td></tr>
<tr class="separator:aea537636e8c42e84195c9f6bc8dfb52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0a2eef022b3834be02e40b6aea556f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a5a0a2eef022b3834be02e40b6aea556f">updateDirtyNodes</a> ()</td></tr>
<tr class="separator:a5a0a2eef022b3834be02e40b6aea556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31114ab2b36a74b6c6fe0c66159ada35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a31114ab2b36a74b6c6fe0c66159ada35">rebuildNeeded</a> () const </td></tr>
<tr class="separator:a31114ab2b36a74b6c6fe0c66159ada35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e847b78e5af9d172799f30eb69917c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#ad8e847b78e5af9d172799f30eb69917c">destroyNode</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node) const </td></tr>
<tr class="separator:ad8e847b78e5af9d172799f30eb69917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c38bcdeae9feb84e93a2a7eaaa6a176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a0c38bcdeae9feb84e93a2a7eaaa6a176">insertObject</a> (<a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *object)</td></tr>
<tr class="separator:a0c38bcdeae9feb84e93a2a7eaaa6a176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e06316c0a94b41a0144e504bfb0fe17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a5e06316c0a94b41a0144e504bfb0fe17">findParent</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node, <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *object) const </td></tr>
<tr class="separator:a5e06316c0a94b41a0144e504bfb0fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd52f5e0855cc4fc48936503b24fe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a97fd52f5e0855cc4fc48936503b24fe7">findNearest</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node, uint64_t const &amp;morton) const </td></tr>
<tr class="separator:a97fd52f5e0855cc4fc48936503b24fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9b6118dda29276eb4c07cc5769382a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#aef9b6118dda29276eb4c07cc5769382a">findVisible</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node, <a class="el" href="class_ocular_1_1_math_1_1_frustum.html">Math::Frustum</a> const &amp;frustum, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const </td></tr>
<tr class="separator:aef9b6118dda29276eb4c07cc5769382a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af730df3c5260407124ca595f1989d250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#af730df3c5260407124ca595f1989d250">findIntersections</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node, <a class="el" href="class_ocular_1_1_math_1_1_ray.html">Math::Ray</a> const &amp;ray, std::vector&lt; std::pair&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *, float &gt;&gt; &amp;objects) const </td></tr>
<tr class="separator:af730df3c5260407124ca595f1989d250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6272ccd89a84df4d6f782de4df258881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a6272ccd89a84df4d6f782de4df258881">findIntersections</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node, <a class="el" href="class_ocular_1_1_math_1_1_bounds_sphere.html">Math::BoundsSphere</a> const &amp;bounds, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const </td></tr>
<tr class="separator:a6272ccd89a84df4d6f782de4df258881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d054aa609e3c73d97531f5ebc75637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#aa2d054aa609e3c73d97531f5ebc75637">findIntersections</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node, <a class="el" href="class_ocular_1_1_math_1_1_bounds_a_a_b_b.html">Math::BoundsAABB</a> const &amp;bounds, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const </td></tr>
<tr class="separator:aa2d054aa609e3c73d97531f5ebc75637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d09592d09bc2cd1d70f6d69b97c062"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#ae6d09592d09bc2cd1d70f6d69b97c062">findIntersections</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node, <a class="el" href="class_ocular_1_1_math_1_1_bounds_o_b_b.html">Math::BoundsOBB</a> const &amp;bounds, std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;objects) const </td></tr>
<tr class="separator:ae6d09592d09bc2cd1d70f6d69b97c062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b12d9f88e4bd5f1805754d6ce2812c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a2b12d9f88e4bd5f1805754d6ce2812c6">build</a> ()</td></tr>
<tr class="separator:a2b12d9f88e4bd5f1805754d6ce2812c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d716100bb7caeb00b97c10a5087ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a16d716100bb7caeb00b97c10a5087ab4">createMortonPairs</a> (std::vector&lt; MortonPair &gt; &amp;pairs) const </td></tr>
<tr class="separator:a16d716100bb7caeb00b97c10a5087ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf24c6896cb2d73863e8c3a66706e22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#aaf24c6896cb2d73863e8c3a66706e22a">generateTree</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *parent, std::vector&lt; MortonPair &gt; const &amp;pairs, uint32_t first, uint32_t last) const </td></tr>
<tr class="separator:aaf24c6896cb2d73863e8c3a66706e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ba5e42f41247df0d9c312ca2e00e2f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#ac3ba5e42f41247df0d9c312ca2e00e2f">findSplit</a> (std::vector&lt; MortonPair &gt; const &amp;pairs, uint32_t first, uint32_t last) const </td></tr>
<tr class="separator:ac3ba5e42f41247df0d9c312ca2e00e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4dc49d654fd5081e3ae4ef018aea26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html#a3e4dc49d654fd5081e3ae4ef018aea26">fitNodeBounds</a> (<a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *node) const </td></tr>
<tr class="separator:a3e4dc49d654fd5081e3ae4ef018aea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_ocular_1_1_core_1_1_i_scene_tree"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_ocular_1_1_core_1_1_i_scene_tree')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html">Ocular::Core::ISceneTree</a></td></tr>
<tr class="memitem:a29b77e3d94d2241caa4052d3c1834ca2 inherit pro_attribs_class_ocular_1_1_core_1_1_i_scene_tree"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b77e3d94d2241caa4052d3c1834ca2"></a>
std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#a29b77e3d94d2241caa4052d3c1834ca2">m_NewObjects</a></td></tr>
<tr class="memdesc:a29b77e3d94d2241caa4052d3c1834ca2 inherit pro_attribs_class_ocular_1_1_core_1_1_i_scene_tree"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newly added objects that are waiting to be added to the tree. <br /></td></tr>
<tr class="separator:a29b77e3d94d2241caa4052d3c1834ca2 inherit pro_attribs_class_ocular_1_1_core_1_1_i_scene_tree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear implementation of a Bounding Volume Hierarchy (BVH) <a class="el" href="class_ocular_1_1_core_1_1_scene.html">Scene</a> Tree. <br />
 For a parallel implementation (GPU) please see ... (does not exist yet).</p>
<p>The BVH Tree is implemented as a binary tree where each leaf node contains exactly one child <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a>. This <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> may itself have child objects attached to it of course, but each node is limited to a single object.</p>
<p>Internal nodes have exactly two child nodes. In the event of an odd amount of leaf nodes, the root node can have direct child leaf nodes.</p>
<p>Enforcing these rules allows for the following to be expected: </p><pre class="fragment">A tree has N leaf nodes
A tree has N-1 internal nodes (including root)
</pre><p>Each node has a corresponding bounding box that encompasses all of it's children. Thus, the bounds of a leaf node are equal to that of it's attached object. The bounds of a internal node contains both of it's children. The bounds of the root then must encompass all objects within the entire scene.</p>
<p>The implementation of this tree is based on several sources: </p><pre class="fragment">Tero Karras, NVIDIA Research
Thinking Parallel, Parts I-III
http://devblogs.nvidia.com/parallelforall/thinking-parallel-part-i-collision-detection-gpu/

Real-Time Rendering, 3rd Edition
...

Daniel Kopta, et al. 
Fast, Effective BVH Updates for Animated Scenes
http://www.cs.utah.edu/~thiago/papers/rotations.pdf</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa0db06e34b8f4667e25296732b8f07a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::addObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the object to the scene tree.</p>
<dl class="section note"><dt>Note</dt><dd>The object will not be instantly added to the tree proper. Instead, they will be added next time the restructure method is invoked. The restructure method is automatically called by the engine periodically. If one needs the object to be immediately available in the tree, then they must manually call the restructure method themselves.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#a269180ecc94b556f57ec0c29137f16f3">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="ae5d2c66cef426490708adbc0aecfac24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::addObjects </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>objects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a collection of objects to the scene tree.</p>
<dl class="section note"><dt>Note</dt><dd>The objects will not be instantly added to the tree proper. Instead, they will be added next time the restructure method is invoked. The restructure method is automatically called by the engine periodically. If one needs the object to be immediately available in the tree, then they must manually call the restructure method themselves.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objects</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#abfa23efd8687e2a51414017dafcbc22e">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="a2b12d9f88e4bd5f1805754d6ce2812c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds the tree from the collection of objects stored in m_AllObjects. </p>

</div>
</div>
<a class="anchor" id="a16d716100bb7caeb00b97c10a5087ab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::createMortonPairs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MortonPair &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates and sorts the Morton Codes for all objects in the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pairs</td><td>Container to be filled with the sorted Morton Codes and their associated <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cf0400122962de731aec03071458d3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the SceneTree and all nodes contained within. Does not destroy any SceneObjects. </p>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#aa145ae6e67e673f0e6e4c2c9a1f4b1c4">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="ad8e847b78e5af9d172799f30eb69917c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::destroyNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safely destroys the specified node and all children. </p>

</div>
</div>
<a class="anchor" id="af730df3c5260407124ca595f1989d250"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::findIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_ray.html">Math::Ray</a> const &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *, float &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively finds all SceneObjects that intersect with the specified ray. The results are unordered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td>Ray to test against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>All discovered SceneObjects that intersect and their intersection points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6272ccd89a84df4d6f782de4df258881"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::findIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_bounds_sphere.html">Math::BoundsSphere</a> const &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively finds all SceneObjects that intersect with the specified bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td>Bounds to test against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>All discovered SceneObjects that intersect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2d054aa609e3c73d97531f5ebc75637"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::findIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_bounds_a_a_b_b.html">Math::BoundsAABB</a> const &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively finds all SceneObjects that intersect with the specified bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td>Bounds to test against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>All discovered SceneObjects that intersect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6d09592d09bc2cd1d70f6d69b97c062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::findIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_bounds_o_b_b.html">Math::BoundsOBB</a> const &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively finds all SceneObjects that intersect with the specified bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td>Bounds to test against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>All discovered SceneObjects that intersect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97fd52f5e0855cc4fc48936503b24fe7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> * Ocular::Core::BVHSceneTree::findNearest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t const &amp;&#160;</td>
          <td class="paramname"><em>morton</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the node with the nearest morton code to the one specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">morton</td><td>Morton code to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest node. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e06316c0a94b41a0144e504bfb0fe17"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> * Ocular::Core::BVHSceneTree::findParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the leaf node that owns the specified object in the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parent node. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3ba5e42f41247df0d9c312ca2e00e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Ocular::Core::BVHSceneTree::findSplit </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; MortonPair &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the index to split the remaining objects to fit the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>Sorted list of morton code/scene object pairings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Index of first object remaining to be added to the tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Index of the last object remaining to be added to the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best index to split the remaining objects. </dd></dl>

</div>
</div>
<a class="anchor" id="aef9b6118dda29276eb4c07cc5769382a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::findVisible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_frustum.html">Math::Frustum</a> const &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">frustum</td><td>Frustum to test against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>All discovered SceneObjects that intersect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e4dc49d654fd5081e3ae4ef018aea26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::fitNodeBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjusts the bounds of the specified node to fit over it's children. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>Node to adjust the bounds of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf24c6896cb2d73863e8c3a66706e22a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> * Ocular::Core::BVHSceneTree::generateTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_node.html">BVHSceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; MortonPair &gt; const &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursively generates the tree in a top-down manner beginning at the root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>The node calling this recursive sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pairs</td><td>Sorted list of morton code/scene object pairings. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>First node in the current split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Last node in the current split (inclusive)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root node of the newly generated tree. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9c91b758e6c90df2bc050bfc69fe55e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::getAllObjects </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a flat list of all objects in the scene tree. No order is guaranteed for the returned objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>List of all objects in the scene tree. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#aabaef879108aeb22b6f497a2e10d3bd4">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="a28d98bef892e8d9f92060efa908aa02b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::getAllVisibleObjects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_frustum.html">Math::Frustum</a> const &amp;&#160;</td>
          <td class="paramname"><em>frustum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a flat list of all visbile objects in the scene tree. No order is guaranteed for the returned objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frustum</td><td>Viewing frustum to check visibility against. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>List of all visible objects in the scene tree. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#a8a7ed9cfc392ba7789a0bfe26a645af9">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="a7f9afdb4c0d17443e040e332dc841cea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::getIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_ray.html">Math::Ray</a> const &amp;&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a list of all scene objects that intersect with the specified ray. The objects are given in the order they are encountered along the ray.</p>
<p>For example, if a ray is created with the origin at the camera and extends along the view direction, then objects[0] will be the object closest to the camera and objects[size-1] will be the object farthest away from the camera.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ray</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>List of objects intersected by the specified ray. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#ab35aede76c39255bb37cc8d1e92432db">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="add58dbcd6257e18f48be57796ca0b1d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::getIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_bounds_sphere.html">Math::BoundsSphere</a> const &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a list of all scene objects that intersect with the sphere. An intersection occurs if a <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> either partially intersects or is entirely contained within the bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>List of objects intersected by the specified bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#af69e2b821e0fc386bd932b9ee7dad257">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="ae5bc8a89a227ca23393e1793cf3fe171"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::getIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_bounds_a_a_b_b.html">Math::BoundsAABB</a> const &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a list of all scene objects that intersect with the specified AABB. An intersection occurs if a <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> either partially intersects or is entirely contained within the bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>List of objects intersected by the specified bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#abf3e5e26d7cde535dd2df1228e7a65e8">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="aa2b49c3d5587aeb0cb1e6ef98f284894"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::getIntersections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_math_1_1_bounds_o_b_b.html">Math::BoundsOBB</a> const &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a list of all scene objects that intersect with the specified OBB. An intersection occurs if a <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> either partially intersects or is entirely contained within the bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bounds</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">objects</td><td>List of objects intersected by the specified bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#a8956c7080a2ad98283f409a7fd6a121b">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="ac65c56973c66324603e1e310d487a8bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SceneTreeType Ocular::Core::BVHSceneTree::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of SceneTree this implementation is. </p>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#aba6e8a3d52f220cbb77996bf2e5fa63a">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="aea537636e8c42e84195c9f6bc8dfb52a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::insertNewObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Individually inserts new objects into the tree.</p>
<p>If the number of new objects that need to be added is significant, then a complete tree rebuild will often be faster and more accurate. </p>

</div>
</div>
<a class="anchor" id="a0c38bcdeae9feb84e93a2a7eaaa6a176"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::insertObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a single new object into the tree. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e21f45bc20e23bb010051f5fb439bcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::rebuild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a complete rebuild of the tree.</p>
<p>This is a potentially costly operation and should only be called when absolutely necessary (either on initial tree construction or when a significant number of new objects have been added). </p>

</div>
</div>
<a class="anchor" id="a31114ab2b36a74b6c6fe0c66159ada35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ocular::Core::BVHSceneTree::rebuildNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks to see if the tree needs to be rebuilt. </p>

</div>
</div>
<a class="anchor" id="abad9359264575fe0389f48b1c7c0ef22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ocular::Core::BVHSceneTree::removeObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the object from the scene tree.</p>
<p>Note that this simply removes the reference to the object and does not actually delete/deallocate the object as that should be handled by the scene manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#a19ce6e41bf568e7371d458535b1a929e">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="aa6cfeced3c516e19fc9ab7741583b6be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::removeObjects </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_ocular_1_1_core_1_1_scene_object.html">SceneObject</a> * &gt; const &amp;&#160;</td>
          <td class="paramname"><em>objects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all objects from the scene tree.</p>
<p>Note that this simply removes the reference to the object and does not actually delete/deallocate the object as that should be handled by the scene manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#a799600672a65d8c03b30c3f8744f7592">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="afb8033e845c33e90c89f3c828a2ffb98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::restructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Periodically called (typically once per frame), this method behaves differently based on the SceneTree implementation. Generally though, it will update interal nodes based on any movement and/or rotation that has happened since the last call. </p>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#ab307c059943f833a056934a309ffdc1d">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="a2fbcc00d258a2448cc2851cbf0291516"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::setDirty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ocular_1_1_core_1_1_u_u_i_d.html">UUID</a> const &amp;&#160;</td>
          <td class="paramname"><em>uuid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates that the tree is dirty, and that the object with the given <a class="el" href="class_ocular_1_1_core_1_1_u_u_i_d.html">UUID</a> was explicitly changed. </p>

<p>Implements <a class="el" href="class_ocular_1_1_core_1_1_i_scene_tree.html#a08bb971267aadd87f2defe0c1dc0f5b8">Ocular::Core::ISceneTree</a>.</p>

</div>
</div>
<a class="anchor" id="a5a0a2eef022b3834be02e40b6aea556f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ocular::Core::BVHSceneTree::updateDirtyNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates all dirty nodes (leafs) whose objects have either moved or rotated. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Update dirty nodes </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Projects/OcularEngine/OcularCore/include/Scene/<a class="el" href="_b_v_h_scene_tree_8hpp_source.html">BVHSceneTree.hpp</a></li>
<li>C:/Projects/OcularEngine/OcularCore/src/Scene/BVHSceneTree.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ocular.html">Ocular</a></li><li class="navelem"><b>Core</b></li><li class="navelem"><a class="el" href="class_ocular_1_1_core_1_1_b_v_h_scene_tree.html">BVHSceneTree</a></li>
    <li class="footer">Generated on Tue Oct 18 2016 01:28:57 for Ocular Engine by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
